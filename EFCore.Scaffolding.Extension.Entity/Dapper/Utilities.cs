namespace EFCore.Scaffolding.Extension.Entity.Dapper
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using System.Xml.Serialization;
    using EFCore.Scaffolding.Extension.Models;
    using global::Dapper;

    internal static class Utilities
    {
        private static readonly ScaffoldConfig scaffoldConfig;
        private static readonly string file;

        static Utilities()
        {
            var di = new DirectoryInfo(Environment.CurrentDirectory);
            file = Directory.GetFiles(di.Parent.Parent.Parent.Parent.FullName, ".Scaffolding.xml", SearchOption.AllDirectories).FirstOrDefault();
            scaffoldConfig = ScaffoldConfig;
        }

        internal static string PK<T>() => scaffoldConfig.GetEntity<T>().PrimaryKey;

        internal static string TableOrViewName<T>() => scaffoldConfig.GetEntity<T>().TableName + scaffoldConfig.GetEntity<T>().ViewName;

        internal static Property[] GetProperties<T>() => scaffoldConfig.GetEntity<T>().Properties;

        internal static ScaffoldConfig ScaffoldConfig => Deserialize(File.ReadAllText(file, Encoding.UTF8));

        internal static List<PropertyInfo> GetPropertyInfos<T>() => typeof(T).GetProperties().ToList();

        internal static void PrepareFirst<T>(out string sql) => sql = $"SELECT TOP 1 * FROM {TableOrViewName<T>()}";

        internal static string GetUpdateSetClause<T>(T entity) => string.Join(",", GetColumnList(entity).Select(o => $"{o}=@{o}"));

        internal static ScaffoldConfig Deserialize(string xml)
        {
            using var sr = new StringReader(xml);
            return (ScaffoldConfig)new XmlSerializer(typeof(ScaffoldConfig)).Deserialize(sr);
        }

        internal static void PrepareDelete<T>(int id, out string sql, out DynamicParameters parameters)
        {
            var keys = PK<T>();
            sql = $"DELETE FROM {TableOrViewName<T>()} WHERE {keys}=@{keys}";
            parameters = new DynamicParameters();
            parameters.Add(keys, id);
        }

        internal static void PrepareDelete<T>(T entity, out string sql, out DynamicParameters parameters)
        {
            var keys = PK<T>();
            sql = $"DELETE FROM {TableOrViewName<T>()} WHERE {keys}=@{keys}";
            parameters = new DynamicParameters();
            string pkPropertyName = GetProperties<T>().FirstOrDefault(o => o.ColumnName == keys).Name;
            var pkPropertyInfo = GetPropertyInfos<T>().FirstOrDefault(o => o.Name == pkPropertyName);
            parameters.Add(keys, pkPropertyInfo.GetValue(entity));
        }

        internal static void PrepareInsert<T>(T entity, out string sql, out DynamicParameters parameters)
        {
            sql = $"INSERT INTO {TableOrViewName<T>()}({string.Join(",", GetColumnList(entity))}) VALUES ({string.Join(",", GetColumnList(entity).Select(column => "@" + column))})";
            PrepareUpdateOrInsertParameters(entity, out parameters);
        }

        internal static void PrepareUpdate<T>(T entity, out string sql, out DynamicParameters parameters)
        {
            sql = $"UPDATE {TableOrViewName<T>()} SET {GetUpdateSetClause(entity)} WHERE {PK<T>()}=@{PK<T>()}";
            PrepareUpdateOrInsertParameters(entity, out parameters);
        }

        internal static void PrepareUpdateOrInsertParameters<T>(T entity, out DynamicParameters parameters)
        {
            parameters = new DynamicParameters();

            // Some parameters may not be needed (automatically generated by the database).
            foreach (var item in GetPropertyInfos<T>())
            {
                var property = scaffoldConfig.GetEntity<T>().Properties.FirstOrDefault(o => o.Name == item.Name);
                if (property != null)
                {
                    parameters.Add(property.ColumnName, ValueConverter.GetConvertedValue(entity, item, property));
                }
            }
        }

        internal static IList<string> GetColumnList<T>(T entity)
        {
            var values = new List<string>();
            foreach (Property property in GetProperties<T>())
            {
                bool isIncrease = !string.IsNullOrEmpty(property.ValueGenerated);
                bool isDefaultValueSql = !string.IsNullOrEmpty(property.DefaultValueSql);

                // Not self-incrementing, no default value (usually a non-primary key field)
                if (!isIncrease && !isDefaultValueSql)
                {
                    values.Add(property.ColumnName);
                    continue;
                }

                // When the space is empty, the database automatically takes the default value field and the value of the property is not the default value.
                if (isDefaultValueSql)
                {
                    var propertyInfo = GetPropertyInfos<T>().FirstOrDefault(o => o.Name == property.Name);
                    var value = propertyInfo.GetValue(entity);
                    switch (propertyInfo.PropertyType.Name)
                    {
                        case nameof(Guid):
                            if ((Guid)value != default)
                            {
                                values.Add(property.ColumnName);
                            }

                            continue;
                        case nameof(Int32):
                            if ((int)value != default)
                            {
                                values.Add(property.ColumnName);
                            }

                            continue;
                        default:
                            throw new NotSupportedException("Not Supported");
                    }
                }
            }

            return values;
        }
    }
}